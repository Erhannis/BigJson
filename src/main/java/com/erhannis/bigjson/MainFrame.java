/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.erhannis.bigjson;

import java.awt.Robot;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.DefaultListModel;
import javax.swing.DropMode;
import javax.swing.JFileChooser;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.ListSelectionModel;
import javax.swing.TransferHandler;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.JSONStreamAware;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

/**
 *
 * @author erhannis
 */
public class MainFrame extends javax.swing.JFrame {
  private JSONStreamAware root;
  private LinkedList<String> locationStack = new LinkedList<>();
  private LinkedList<int[]> selectionStack = new LinkedList<>();
  private LinkedList<Object> stack = new LinkedList<>();
  private DefaultListModel<JsonStringWrapper> listModel = new DefaultListModel<>();

  /**
   * Creates new form MainFrame
   */
  public MainFrame() {
    initComponents();

    jList1.setCellRenderer(new JsonCellRenderer());
    jList1.setModel(listModel);
    jList1.updateUI();
    //jList1.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
    jList1.addKeyListener(new KeyListener() {
      @Override
      public void keyTyped(KeyEvent ke) {
      }

      @Override
      public void keyPressed(KeyEvent ke) {
      }

      @Override
      public void keyReleased(KeyEvent ke) {
        switch (ke.getKeyCode()) {
          case KeyEvent.VK_ENTER: {
            int[] sels = jList1.getSelectedIndices().clone();
            if (sels.length > 0) {
              JsonStringWrapper wrap = jList1.getSelectedValue();
              if (wrap.obj instanceof Entry) {
                stack.push(((Entry) wrap.obj).getValue());
                locationStack.push("" + ((Entry) wrap.obj).getKey());
                selectionStack.push(sels);
              } else {
                stack.push(wrap.obj);
                locationStack.push("" + sels[0]);
                selectionStack.push(sels);
              }
              updateList();
            }
            break;
          }
          case KeyEvent.VK_BACK_SPACE:
          case KeyEvent.VK_ESCAPE: {
            if (!stack.isEmpty()) {
              stack.pop();
              locationStack.pop();
              int[] sels = selectionStack.pop();
              updateList();
              jList1.setSelectedIndices(sels);
            }
            break;
          }
          case KeyEvent.VK_DELETE:
            if (!stack.isEmpty()) {
              int[] sels = jList1.getSelectedIndices().clone();
              Arrays.parallelSort(sels);
              Object obj = stack.peek();
              if (obj instanceof JSONArray) {
                JSONArray arr = (JSONArray) obj;
                int offset = 0;
                for (int idx : sels) {
                  arr.remove(idx + offset);
                  offset -= 1;
                }
              } else if (obj instanceof JSONObject) {
                JSONObject jobj = (JSONObject) obj;
                Object[] keys = Arrays.stream(sels).mapToObj(i -> ((Entry) listModel.get(i).obj).getKey()).toArray();
                for (Object key : keys) {
                  jobj.remove(key);
                }
              } else {
                //????
              }
              updateList();
              if (sels.length == 1 && listModel.size() > sels[0]) {
                jList1.setSelectedIndex(sels[0]);
              }
            }
            break;
        }
      }
    });
  }

  /**
   * This method is called from within the constructor to initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is always
   * regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    jSplitPane1 = new javax.swing.JSplitPane();
    jPanel1 = new javax.swing.JPanel();
    btnLoad = new javax.swing.JButton();
    btnSave = new javax.swing.JButton();
    btnCopy = new javax.swing.JButton();
    bntPaste = new javax.swing.JButton();
    btnRelayer = new javax.swing.JButton();
    btnRetab = new javax.swing.JButton();
    btnDeimage = new javax.swing.JButton();
    btnUnique = new javax.swing.JButton();
    jPanel2 = new javax.swing.JPanel();
    jScrollPane1 = new javax.swing.JScrollPane();
    jList1 = new javax.swing.JList<>();
    tfLocation = new javax.swing.JTextField();

    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

    jSplitPane1.setDividerLocation(150);

    btnLoad.setText("Load");
    btnLoad.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        btnLoadActionPerformed(evt);
      }
    });

    btnSave.setText("Save");
    btnSave.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        btnSaveActionPerformed(evt);
      }
    });

    btnCopy.setText("Copy");
    btnCopy.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        btnCopyActionPerformed(evt);
      }
    });

    bntPaste.setText("Paste");
    bntPaste.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        bntPasteActionPerformed(evt);
      }
    });

    btnRelayer.setText("Relayer");
    btnRelayer.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        btnRelayerActionPerformed(evt);
      }
    });

    btnRetab.setText("Retab");
    btnRetab.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        btnRetabActionPerformed(evt);
      }
    });

    btnDeimage.setText("Deimage");
    btnDeimage.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        btnDeimageActionPerformed(evt);
      }
    });

    btnUnique.setText("Unique");
    btnUnique.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        btnUniqueActionPerformed(evt);
      }
    });

    javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
    jPanel1.setLayout(jPanel1Layout);
    jPanel1Layout.setHorizontalGroup(
      jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(jPanel1Layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addGroup(jPanel1Layout.createSequentialGroup()
            .addComponent(btnLoad)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
            .addComponent(btnSave))
          .addGroup(jPanel1Layout.createSequentialGroup()
            .addComponent(btnCopy)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
            .addComponent(bntPaste))
          .addComponent(btnRelayer)
          .addComponent(btnRetab)
          .addComponent(btnDeimage)
          .addComponent(btnUnique))
        .addContainerGap(42, Short.MAX_VALUE))
    );
    jPanel1Layout.setVerticalGroup(
      jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(btnCopy)
          .addComponent(bntPaste))
        .addGap(18, 18, 18)
        .addComponent(btnRelayer)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(btnRetab)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(btnDeimage)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(btnUnique)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 131, Short.MAX_VALUE)
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(btnLoad)
          .addComponent(btnSave))
        .addContainerGap())
    );

    jSplitPane1.setLeftComponent(jPanel1);

    jScrollPane1.setViewportView(jList1);

    tfLocation.setToolTipText("Location");

    javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
    jPanel2.setLayout(jPanel2Layout);
    jPanel2Layout.setHorizontalGroup(
      jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addComponent(tfLocation)
      .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 413, Short.MAX_VALUE)
    );
    jPanel2Layout.setVerticalGroup(
      jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(jPanel2Layout.createSequentialGroup()
        .addComponent(tfLocation, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 323, Short.MAX_VALUE))
    );

    jSplitPane1.setRightComponent(jPanel2);

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addComponent(jSplitPane1)
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addComponent(jSplitPane1)
    );

    pack();
  }// </editor-fold>//GEN-END:initComponents

  private JFileChooser fileChooser = new JFileChooser(".");
 
  private void btnLoadActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnLoadActionPerformed
    try {
      if (fileChooser.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {
        load(fileChooser.getSelectedFile());
      }
    } catch (IOException ex) {
      Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
    } catch (ParseException ex) {
      Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
    }
  }//GEN-LAST:event_btnLoadActionPerformed

  private void btnSaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSaveActionPerformed
    try {
      if (fileChooser.showSaveDialog(null) == JFileChooser.APPROVE_OPTION) {
        save(fileChooser.getSelectedFile());
      }
    } catch (IOException ex) {
      Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
    }
  }//GEN-LAST:event_btnSaveActionPerformed

  private void btnCopyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCopyActionPerformed
    try {
      copy();
    } catch (IOException ex) {
      Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
    }
  }//GEN-LAST:event_btnCopyActionPerformed

  private void bntPasteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bntPasteActionPerformed
    try {
      paste(TEMP_FILE);
    } catch (UnsupportedFlavorException ex) {
      Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
    } catch (IOException ex) {
      Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
    } catch (ParseException ex) {
      Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
    } catch (IllegalArgumentException ex) {
      Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
    }
  }//GEN-LAST:event_bntPasteActionPerformed

  private void btnRelayerActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnRelayerActionPerformed
    remapArray(this::relayer);
  }//GEN-LAST:event_btnRelayerActionPerformed

  private void btnRetabActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnRetabActionPerformed
    remapArray(this::retab);
  }//GEN-LAST:event_btnRetabActionPerformed

  private void btnDeimageActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDeimageActionPerformed
    remapArray(this::deimage);
  }//GEN-LAST:event_btnDeimageActionPerformed

  private void btnUniqueActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnUniqueActionPerformed
    remapArray(this::unique);
  }//GEN-LAST:event_btnUniqueActionPerformed

  private void load(File f) throws FileNotFoundException, IOException, ParseException {
    JSONObject obj;
    try (FileReader fr = new FileReader(f)) {
      obj = (JSONObject) new JSONParser().parse(fr);
    }
    root = obj;
    stack.clear();
    locationStack.clear();
    selectionStack.clear();
    updateList();
  }

  private void save(File f) throws IOException {
    try (FileWriter fw = new FileWriter(f)) {
      root.writeJSONString(fw);
      fw.flush();
    }
  }

  private void save(JSONStreamAware obj, File f) throws IOException {
    try (FileWriter fw = new FileWriter(f)) {
      obj.writeJSONString(fw);
      fw.flush();
    }
  }
  
  private void updateList() {
    listModel.clear();
    if (stack.isEmpty()) {
      listModel.addElement(new JsonStringWrapper(root));
    } else {
      Object o = stack.peek();
      if (o instanceof JSONArray) {
        JSONArray arr = (JSONArray) o;
        for (int i = 0; i < arr.size(); i++) {
          listModel.addElement(new JsonStringWrapper(arr.get(i)));
        }
      } else if (o instanceof JSONObject) {
        JSONObject obj = (JSONObject) o;
        for (Object entry : obj.entrySet()) {
          listModel.addElement(new JsonStringWrapper(entry));
        }
      } else {
        listModel.addElement(new JsonStringWrapper(o));
      }
    }
    jList1.updateUI();
    tfLocation.setText(locationStack.stream().reduce("", (s1, s2) -> s2 + "." + s1));
  }

  private void paste(File f) throws UnsupportedFlavorException, IOException, ParseException {
    Object obj;
    try (FileReader fr = new FileReader(f)) {
      obj = new JSONParser().parse(fr);
    }
    if (!stack.isEmpty()) {
      Object parent = stack.peek();
      if (obj instanceof JSONArray) {
        JSONArray ja = (JSONArray) obj;
        if (parent instanceof JSONArray) {
          ((JSONArray)parent).addAll(ja);
        } else if (parent instanceof JSONObject) {
          //TODO
          throw new IllegalArgumentException("Adding keys not yet implemented");
        } else {
          throw new IllegalArgumentException("error parent is weird");
        }
      } else if (obj instanceof JSONObject) {
        JSONObject jo = (JSONObject) obj;
        if (parent instanceof JSONArray) {
          ((JSONArray)parent).addAll(jo.values());
        } else if (parent instanceof JSONObject) {
          ((JSONObject)parent).putAll(jo);
        } else {
          throw new IllegalArgumentException("error parent is weird");
        }
      } else {
        throw new IllegalArgumentException("error need array or object");
      }
    } else {
      throw new IllegalArgumentException("error can't paste next to root");
    }
    selectionStack.clear();
    updateList();
  }

  private static final File TEMP_FILE = new File(System.getProperty("java.io.tmpdir"), "bigjson.json");
  
  private void copy() throws IOException {
    if (!stack.isEmpty()) {
      int[] sels = jList1.getSelectedIndices().clone();
      Arrays.parallelSort(sels);
      Object obj = stack.peek();
      if (obj instanceof JSONArray) {
        JSONArray target = new JSONArray();
        JSONArray arr = (JSONArray) obj;
        for (int idx : sels) {
          target.add(arr.get(idx));
        }
        save(target, TEMP_FILE);
      } else if (obj instanceof JSONObject) {
        JSONObject target = new JSONObject();
        JSONObject jobj = (JSONObject) obj;
        Object[] keys = Arrays.stream(sels).mapToObj(i -> ((Entry) listModel.get(i).obj).getKey()).toArray();
        for (Object key : keys) {
          target.put(key, jobj.get(key));
        }
        save(target, TEMP_FILE);
      } else {
        // Default
        JSONArray target = new JSONArray();
        for (JsonStringWrapper wrapper : jList1.getSelectedValuesList()) {
          target.add(wrapper.obj);
        }
        save(target, TEMP_FILE);
      }
    } else {
      // Default
      JSONArray target = new JSONArray();
      for (JsonStringWrapper wrapper : jList1.getSelectedValuesList()) {
        target.add(wrapper.obj);
      }
      save(target, TEMP_FILE);
    }
  }

  private JSONArray target = null;
  
  private void remapArray(Consumer<JSONArray> targetFunc) {
    if (!stack.isEmpty()) {
      int sel = jList1.getSelectedIndex();
      if (sel > -1) {
        Object obj = stack.peek();
        if (obj instanceof JSONArray) {
          JSONArray arr = (JSONArray) obj;
          targetFunc.accept((JSONArray)arr.get(sel));
        } else if (obj instanceof JSONObject) {
          JSONObject jobj = (JSONObject) obj;
          Object key = ((Entry) listModel.get(sel).obj).getKey();
          targetFunc.accept((JSONArray)jobj.get(key));
        } else {
          // Default
          JsonStringWrapper wrapper = jList1.getSelectedValue();
          targetFunc.accept((JSONArray)wrapper.obj);
        }
      }
    }    
  }
  
  private void deimage(JSONArray target) {
    LinkedList<Object> pending = new LinkedList<>();
    HashSet<Object> done = new HashSet<>();
    pending.add(target);
    done.add(target);
    while (!pending.isEmpty()) {
      Object obj = pending.removeFirst();
      if (obj instanceof JSONArray) {
        JSONArray arr = (JSONArray) obj;
        for (int i = 0; i < arr.size(); i++) {
          Object child = arr.get(i);
          if (!done.contains(child)) {
            pending.addLast(child);
            done.add(child);
          }
          if (child instanceof String && ((String)child).startsWith("data:image")) {
            arr.set(i, "");
          }
        }
      } else if (obj instanceof JSONObject) {
        JSONObject jobj = (JSONObject) obj;
        for (Map.Entry child : ((Set<Map.Entry>)jobj.entrySet())) {
          if (!done.contains(child.getValue())) {
            pending.addLast(child.getValue());
            done.add(child);
          }
          if (child.getValue() instanceof String && ((String)child.getValue()).startsWith("data:image")) {
            child.setValue("");
          }
        }
      }
    }
    System.out.println("processed objects: " + done.size());
  }

  private void relayer(JSONArray target) {
    LinkedList<Object> pending = new LinkedList<>();
    HashSet<Object> done = new HashSet<>();
    pending.add(target);
    done.add(target);
    int count = 0;
    ArrayList<Object[]> toMove = new ArrayList<>();
    int repeatCount = 0;
    HashSet<Object> repeated = new HashSet<>();
    while (!pending.isEmpty()) {
      Object obj = pending.removeFirst();
      if (obj instanceof JSONArray) {
        JSONArray arr = (JSONArray) obj;
        for (Object child : arr) {
          if (!done.contains(child)) {
            pending.addLast(child);
            done.add(child);
          } else {
            if (child instanceof JSONStreamAware) {
              repeatCount++;
              repeated.add(child);
            }
          }
        }
      } else if (obj instanceof JSONObject) {
        JSONObject jobj = (JSONObject) obj;
        for (Map.Entry child : ((Set<Map.Entry>)jobj.entrySet())) {
          if (!done.contains(child.getValue())) {
            pending.addLast(child.getValue());
            done.add(child);
          } else {
            if (child instanceof JSONStreamAware) {
              repeatCount++;
              repeated.add(child);
            }
          }
        }
        tryblock: try {
          Object o;
          o = jobj.entrySet().stream().filter(e -> "tabs".equals(((Map.Entry)e).getKey())).map(e -> ((Map.Entry)e).getValue()).findFirst().orElse(null);
          if (o == null || !(o instanceof JSONArray)) break tryblock;
          JSONArray ja = (JSONArray)o;
          for (int i = 0; i < ja.size(); i++) {
            Object o2 = ja.get(i);
            if (o2 instanceof JSONObject) {
              //Object formdata = ((JSONObject) o2).get("formdata");
              Object formdata = ((JSONObject) o2).entrySet().stream().filter(e -> "formdata".equals(((Map.Entry)e).getKey())).map(e -> ((Map.Entry)e).getValue()).findFirst().orElse(null);
              if (formdata != null && formdata instanceof JSONObject) {
                //Object url = ((JSONObject) formdata).get("url");
                Object url = ((JSONObject) formdata).entrySet().stream().filter(e -> "url".equals(((Map.Entry)e).getKey())).map(e -> ((Map.Entry)e).getValue()).findFirst().orElse(null);
                if ("about:sessionrestore".equals(url)) {
                  count++;
                  //TODO I don't get it.  This shouldn't be able to affect the total count.
//                    ja.remove(i);
//                    i--;
//                    target.add(o2);
                  toMove.add(new Object[]{ja, o2});
                }
              }
            }
          }
        } catch (Throwable t) {
          t.printStackTrace();
        }
      }
    }
    System.out.println("processed objects: " + done.size());
    System.out.println("impossible repeats: " + repeatCount);
    System.out.println("found sessionrestores: " + count);
    int tc = 0;
    int fc = 0;
    for (Object[] pair : toMove) {
      if (repeated.contains(pair[1])) {
        System.out.println("SR found repeated");
      }
      if (((JSONArray)pair[0]).remove(pair[1])) {
        tc++;
      } else {
        fc++;
      }
      target.add(pair[1]);
    }
    System.out.println("Arrays modified: " + tc);
    System.out.println("Arrays NOT MODIFIED: " + fc);
  }
  
  private void retab(JSONArray target) {
    LinkedList<Object> pending = new LinkedList<>();
    HashSet<Object> done = new HashSet<>();
    pending.add(target);
    done.add(target);
    int count = 0;
    ArrayList<Object[]> toMove = new ArrayList<>();
    int repeatCount = 0;
    HashSet<Object> repeated = new HashSet<>();
    while (!pending.isEmpty()) {
      Object obj = pending.removeFirst();
      if (obj instanceof JSONArray) {
        JSONArray arr = (JSONArray) obj;
        for (Object child : arr) {
          if (!done.contains(child)) {
            pending.addLast(child);
            done.add(child);
          } else {
            if (child instanceof JSONStreamAware) {
              repeatCount++;
              repeated.add(child);
            }
          }
        }
      } else if (obj instanceof JSONObject) {
        JSONObject jobj = (JSONObject) obj;
        for (Map.Entry child : ((Set<Map.Entry>)jobj.entrySet())) {
          if (!done.contains(child.getValue())) {
            pending.addLast(child.getValue());
            done.add(child);
          } else {
            if (child instanceof JSONStreamAware) {
              repeatCount++;
              repeated.add(child);
            }
          }
        }
        tryblock: try {
          Object o;
          o = jobj.entrySet().stream().filter(e -> "tabs".equals(((Map.Entry)e).getKey())).map(e -> ((Map.Entry)e).getValue()).findFirst().orElse(null);
          if (o == null || !(o instanceof JSONArray)) break tryblock;
          JSONArray ja = (JSONArray)o;
          for (int i = 0; i < ja.size(); i++) {
            Object o2 = ja.get(i);
            count++;
            toMove.add(new Object[]{ja, o2});
          }
        } catch (Throwable t) {
          t.printStackTrace();
        }
      }
    }
    System.out.println("processed objects: " + done.size());
    System.out.println("impossible repeats: " + repeatCount);
    System.out.println("found tabs: " + count);
    int tc = 0;
    int fc = 0;
    for (Object[] pair : toMove) {
      if (repeated.contains(pair[1])) {
        System.out.println("SR found repeated");
      }
      if (((JSONArray)pair[0]).remove(pair[1])) {
        tc++;
      } else {
        fc++;
      }
      target.add(pair[1]);
    }
    System.out.println("Arrays modified: " + tc);
    System.out.println("Arrays NOT MODIFIED: " + fc);
  }

  private void deimage(JSONArray target) {
    LinkedList<Object> pending = new LinkedList<>();
    HashSet<Object> done = new HashSet<>();
    pending.add(target);
    done.add(target);
    while (!pending.isEmpty()) {
      Object obj = pending.removeFirst();
      if (obj instanceof JSONArray) {
        JSONArray arr = (JSONArray) obj;
        for (int i = 0; i < arr.size(); i++) {
          Object child = arr.get(i);
          if (!done.contains(child)) {
            pending.addLast(child);
            done.add(child);
          }
          if (child instanceof String && ((String)child).startsWith("data:image")) {
            arr.set(i, "");
          }
        }
      } else if (obj instanceof JSONObject) {
        JSONObject jobj = (JSONObject) obj;
        for (Map.Entry child : ((Set<Map.Entry>)jobj.entrySet())) {
          if (!done.contains(child.getValue())) {
            pending.addLast(child.getValue());
            done.add(child);
          }
          if (child.getValue() instanceof String && ((String)child.getValue()).startsWith("data:image")) {
            child.setValue("");
          }
        }
      }
    }
    System.out.println("processed objects: " + done.size());
  }
  
  private void unique(JSONArray target) {
    int count = target.size();
    int repeats = 0;
    HashSet<String> strings = new HashSet<>();
    Iterator it = target.iterator();
    while (it.hasNext()) {
      Object obj = it.next();
      String str = JsonStringWrapper.calcString(obj);
      if (!str.contains("asdfasdfafsfawefasdfzsdc")) {
        if (!strings.add(str)) {
          repeats++;
        }
      }
    }
    System.out.println("processed objects: " + count);
    System.out.println("repeats: " + repeats);
  }

  /**
   * @param args the command line arguments
   */
  public static void main(String args[]) {
    /* Set the Nimbus look and feel */
    //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
    /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
     */
    try {
      for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
        if ("Nimbus".equals(info.getName())) {
          javax.swing.UIManager.setLookAndFeel(info.getClassName());
          break;
        }
      }
    } catch (ClassNotFoundException ex) {
      java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
      java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
      java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
      java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    //</editor-fold>

    /* Create and display the form */
    java.awt.EventQueue.invokeLater(new Runnable() {
      public void run() {
        new MainFrame().setVisible(true);
      }
    });
  }

  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JButton bntPaste;
  private javax.swing.JButton btnCopy;
  private javax.swing.JButton btnDeimage;
  private javax.swing.JButton btnLoad;
  private javax.swing.JButton btnRelayer;
  private javax.swing.JButton btnRetab;
  private javax.swing.JButton btnSave;
  private javax.swing.JButton btnUnique;
  private javax.swing.JList<JsonStringWrapper> jList1;
  private javax.swing.JPanel jPanel1;
  private javax.swing.JPanel jPanel2;
  private javax.swing.JScrollPane jScrollPane1;
  private javax.swing.JSplitPane jSplitPane1;
  private javax.swing.JTextField tfLocation;
  // End of variables declaration//GEN-END:variables
}
